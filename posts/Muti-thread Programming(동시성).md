---
tags:
  - dev
  - concurrency
dg-publish: true
---
## 동시성이 필요한 이유는 무엇인가
---
동시성은 what과 when을 분리하여 구조/효율성을 극대화하는 방법이다. 예로 Servlet 모델은 컨테이너가 다중으로 들어오는 웹 요청을 관리함으로써 구조적 이점을 준다. 요청 들 어올 때마다 비동기적으로 서블릿을 실행시키며, 서블릿 스레드가 다른 서블릿 스레드와 독립적으로 수행되어 요청을 처리한다. 또한 수 많은 웹사이트에서 정보를 가져와 처리하는 정보수집기는 여러 웹사이트를 동시에 방문하여 정보를 가져옴으로써 처리량을 올릴 수 있다.
## 동시성의 특징
---
- 대기 시간이 길어서 여러 스레드가 프로세서를 공유할 수 있거나(위 사례) 여러 프로세서가 동시에 처리할 독립적인 계산이 많은 경우(1~ 1조까지 계산한다고 치면, 4개 프로 세서가 1/4씩 계산하고 나중에 합치면된다 병렬성?)에만 성능 향상을 기대할 수 있다.
- 단일 스레드 시스템과 다중 스레드 시스템은 설계가 다르다
- 웹 컨테이너가 스레드를 관리하지만 동시성을 이해하고 있어야 한다.
- 동시성은 성능 부하를 유발하며, 코드도 더 많다
- 동시성은 복잡하다
- 동시성 버그는 재현하기 어렵고 버그로 간주되지 않을 확률이 높다
## 동시성을 구현하기 어려운 이유
---
### 가시성(메모리에 대한 가시성)
- CPU가 작업할 때 메모리에서 값을 바로 가져오거나 바로 쓰는게 아니라, CPU캐쉬에 작업 대상을 가져와 사용하기 때문에 메모리와 캐쉬간 싱크가 맞지 않을 수 있다. 즉, A thread가 공유 객체의 값을 변경 완료했지만, 해당 값이 메모리에는 존재하지 않아 B thread가 변경 이전 값을 참조할 수 있다.
- synchrorized 키워드를 사용하여 블록킹하거나 volitle 키워드를 사용하여 변경사항을 메모리에 바로 flush할 수 있다.
- 
### 원자성(연산의 원자성)
- 다른 스레드에 의해서 중단 및 개입이 불가능하여 처리 결과가 오염되지 않는 최소 연산 단위를 원자적 연산이라고 한다.
- i++의 경우 read, modify, write의 3단계로 이루어 지기 때문에 중간에 다른 스레드에 의해 연산 작업이 중복으로 일어나 늦게 실행된 연산작업은 반영되지 않을 수 있다.
- synchronized 키워드를 사용하여 블록킹하거나 CAS 전략(Atomic 시리즈)을 사용하여 논블록킹하여 해결할 수 있다. 
## 동시성 버그 방어를 위한 원칙
---
• SRP를 준수 하라. 동시성코드는 독자적인 개발/변경 주기가 있다. 동시성코드는 동시성 하나만으로도 버그를 유발하기 쉽다.
• 자료를 캡슐화하여 공유되는 자료를 수정하는 위치를 최소화 하고, 공유객체를 사용하는 코드 내 영역을 synchronized로 보호하라.
• 객체를 복사해서 읽기 전용으로 사용하라. 잠금 비용을 없앰으로써 사본 생성 및 가비지 컬렌션에 드는 비용을 상쇄할 수도 있다.
• 다른 스레드와 자료를 공유하지 않고 모든 정보를 로컬 변수에 저장해서 처리하라.
• 공유객체 하나에는 매서드를 하나만 사용하라. 매서드 사이에 의존성이 존재하면 버그 발생시 찾아내기 어렵다.
• 동기화하는 부분을 작게 만들어라. synchronized 키워드 등으로 락을 사용해 감싸게 되면 스레드를 지연시키고 부하가 생긴다.
멀티 스레드 작업을 올바르게 종료시키는 코드는 구현이 어려우므로 개발 초기부터 고민하라.
## 스레드 코드 테스트하기
---
- 멀티 스레드 환경에서 발생하는 시스템 실패는 재현하기 아주 어렵다. 일회성 문제라고 판단하지 마라.
- 멀티 스레드가 아닌 순차 코드부터 제대로 작동하게 만들어라.
- 다양한 환경에서 테스트를 하라.(스레드 수, 실제 환경/테스트 환경, 속도, 반복)
- 스레드 개수를 다이나믹하게 설정할 수 있게 고려하라.
- 프로세서보다 많은 스레드를 수행하여 스와핑 테스트를 하라.
- 다른 플랫폼에서 돌려보라.
- 강제로 실패를 일으키기 위해 스레드를 대기 시키거나 우선순위를 바꾸는 등의 보조 코드를 추가해서 테스트하라.
## 동시성 관련 라이브러리
---
- ReetrantLock: 한 메서드에서 잠그고 다른 메서드에서 푸는 락
- Semaphore: 공유자원에 접근 가능한 스레드 수를 설정할 수 있는 락
- CountDownLatch: 지정한 수만큼 이벤트를 발생 + 해당 이벤트가 종료될때마다 카운트를 하여 모든 스레드 작업이 진행된 후에 해제하는 락
- 스레드에 안전한 컬렉션 (ex - ConcurrentHashMap, CAS전략 및 syncronized를 활용하여 멀티 스레드 환경에서 안전하게 사용가능)
## 동시성 기본 개념
--- 
- 한정된 자원: 멀티 스레드 환경에서 각 스레드가 각자의 작업을 처리하기 위해 획득해야하는 자원. DB 커넥션이나 읽기쓰기 버퍼 등
- 상호 배제: 한 번에 한 스레드가 공유자료/공유자원을 사용할 수 있는 경우 (레이스 컨디션이 일어나지 않게 함)
	- Mutex (Mutual Exclusion)
	- 싱크로나이즈드 키워드로 임계영역을 보호한다
	- ReentantLock으로 사용자 의도에 맞게 lock/unlock을 명시적으로 호출한다
	- Semaphore으로 사용자 의도에 맞게 acquire/release를 명시적으로 호출한다 + 해당영역에 접근할 수 있는 스레드를 n개로 설정한다.
- 기아: 우선순위가 높은 스레드에게 자원을 할당하는 경우, 우선순위가 낮은 스레드들이 자원을 획득하지 못하는 현상
- 데드락: 여러 스레드가 서로 끝나기를 기다리는 상황
	- 점유와 대기 (서로의 자원을 점유하여 서로 대기하는 상태)
	- 상호배제
	- 비선점 (스레드의 우선순위가 같아서 어떤 스레드가 자원을 가져갈 지 알 수 없는 상태)
	- 순환 대기 (다른 스레드의 작업이 끝나기를 기다리는 상태가 체이닝되는 현상)
-  라이브락: 각 스레드가 락 획득과 해제를 반복하는 현상(마주오는 사람들 끼리 길 비켜주다 길 막는 상황...)으로 데드락을 해결하려고 시도하는 과정에서 주로 발상
- 가시성
- 원자성
- CAS 전략
## 동시성 실행모델
---
- 생산자-소비자 모델
- 읽기-쓰기 모델
- 식사하는 철학자들 모델
## 참조
---
- Clean Code 8장 Multi-thread Programming Best Prctices
- [CAS 전략](http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html)
- [Countdown Latch](https://velog.io/@sa1341/CountDownLatch-%ED%81%B4%EB%9%98%EC%84%A4)
- [[Thread]]
- [[Executors]]
